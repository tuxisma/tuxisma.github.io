<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Deploying Java Aplications With Kubernetes - Ismael Garcia&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="">
  <meta name="keywords" content="">
  <link rel="canonical" href="https://tuxisma.github.io/post/deploying-java-aplications-with-kubernetes/">

  
  

  
  

  
  

  <link rel="stylesheet" type="text/css" href="https://tuxisma.github.io/css/combined-min.css">
  <link rel="stylesheet" type="text/css" href="https://tuxisma.github.io/tipuesearch/tipuesearch.css">

</head>
<body class="">

<div class="site-wrap">
  <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="https://tuxisma.github.io" class="site-title">Ismael Garcia&#39;s blog</a>
      <nav class="site-nav right">
      <a href="https://tuxisma.github.io/about/">About</a>
<a href="https://tuxisma.github.io/tags/">Tags</a>
<a href="https://tuxisma.github.io/contact/">Contact</a>
<form class="navbar-search" action="https://tuxisma.github.io/search/index.html"
    onsubmit="return validateForm(this.elements['q'].value);">
    <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input">

</form>

      </nav>
      <div class="clearfix"></div>
    </div>
  </div>
</header>

  <div class="post p2 p-responsive wrap" role="main">
    <div class="measure">
      <div class="post-header mb2">
        <h1 class="py2">Deploying Java Aplications With Kubernetes</h1>
        <span class="post-meta">Jan 11, 2018 by Ismael Garcia</span><br>
        
      </div>

      <article class="post-content">
      

<p>Three months ago I was learning Docker swarm now I&rsquo;m learning kubernetes as orchestrator this year I&rsquo;m gonna write about k8s a lot so the idea here is show how to deploy Java Aplications within Docker Containers orchestra them with Kubernetes.</p>

<p>When you run containers you always gonna need a orchestrator in order to be more efficient, faster and continuous delivery and so on that&rsquo;s the reason why I&rsquo;ve chosen kubernetes and the true is basically because is the most popular I would say it&rsquo;s so robust, ambicious, fault-tolerance, scaling, discovery abilities and why not use it, mainly was created at Google and now is hosted by the <a href="https://www.cncf.io/" target="_blank">Cloud Native Computing Foundation(CNCF)</a>.</p>

<h3 id="let-s-see-the-architecture-of-the-docker-java-shopfront-application">Let&rsquo;s see the architecture of the &laquo;Docker Java Shopfront&raquo; application:</h3>

<p><img src="https://d3ansictanv2wj.cloudfront.net/fig_1-f5792a21c68293bc220dbfe5244a0829.png" alt="Docker Java" title="Docker Java Shopfront" /></p>

<p>Now I will write some concepts which it&rsquo;s important know.</p>

<ul>
<li><strong>kubectl</strong> Kubernetes command-line tool which control the kubernetes cluster manager.</li>
<li><strong>labels</strong> It&rsquo;s the way how we can identify pods and be selected we have the freedom of write in JSON or YAML format.</li>
<li><strong>Pods</strong> is essentially a group of one o more containers we can say it&rsquo;s a set of one or many containers sharing the same IP, share a filesystem and network namespace. The way how k8s communicate with pods is through kubectl.</li>
<li><strong>Services</strong> Provide load balancing, naming and discovery to isolate one microservices from another working together with Replications Controller which ensure that containers are working within pods correctly.</li>
</ul>

<p>Prerequisities:</p>

<ul>
<li><p>Docker for Mac/Windows/Linux Kubernetes will work with one of the most popular provider containers (Docker).</p></li>

<li><p>Minikube It&rsquo;s a tool that run a single-node Kuebernetes test cluster via VM.</p></li>

<li><p>A github account and Git - The examples(code) of this deployments are hosted in github, using git locally you can clone, fork, commit and so on.</p></li>

<li><p>Docker hub account - You will need to host your images but it&rsquo;s up to you because you can use the original source.</p></li>

<li><p>Java 8 or 9 SDK and Maven(mvn) - We will use Maven(in my case I didn&rsquo;t install mvn I just runned a container with Maven into a Container, you see the step next) in order to build code and dependency tool that uses Java 8.</p></li>
</ul>

<h3 id="let-s-create-a-service-for-shopfront">Let&rsquo;s create a service for shopfront</h3>

<p>Clone the repository:</p>

<pre><code>$ git clone git@github.com:tuxisma/oreilly-docker-java-shopping.git

$ cd oreilly-docker-java-shopping/shopfront

</code></pre>

<p>I loaded the code of shopfront on sublime in order to look into it.</p>

<p><img src="https://farm5.staticflickr.com/4678/38757522125_40ab8779e1_b.jpg" alt="alt text" title="code shopfront" />
This code is one of them.</p>

<p>Now we gonna build the application using Maven as a result of  -we will see a JAR located in the ./target directory.</p>

<p>Here a trick:</p>

<p>I didn&rsquo;t install Maven but I need to have mvn which means I can run it into a container, just go into <code>shopfront/</code> and mvn will take the pom.xml file.
(Trick share it by <a href="https://github.com/yazpik" title="yazpik" target="_blank">yazpik</a>  )</p>

<pre><code>docker run -it --rm -v $PWD:/usr/src/mymaven -w /usr/src/mymaven maven  mvn clean install
</code></pre>

<p>Now I will create a image from Dockerfile:</p>

<pre><code>FROM openjdk:8-jre
ADD target/shopfront-0.0.1-SNAPSHOT.jar app.jar
EXPOSE 8010
ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
</code></pre>

<p>Our container image shuld be created from the openjdk:8-jre, the second line adds the app to the image, the third line specify that our app will be available through port 8010 and the last line specifies the entrypoint which means the command to run when container is initialized.</p>

<p>Let&rsquo;s build the image:</p>

<p>tuxisma(user on dockerhub)</p>

<pre><code>$ docker build -t tuxisma/djshopfront:1.0 .
Successfully built 87b8c5aa5260
Successfully tagged tuxisma/djshopfront:1.0
</code></pre>

<p>Non I will push the image to Docker Hub.</p>

<pre><code>$ docker login
Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.
Username:
Password:
Login Succeeded
$
$ docker push tuxisma/djshopfront:1.0
The push refers to a repository [docker.io/tuxisma/djshopfront]
9b19f75e8748: Pushed 
...
cf4ecb492384: Pushed 
1.0: digest: sha256:8a6b459b0210409e67bee29d25bb512344045bd84a262ede80777edfcff3d9a0 size: 2210

</code></pre>

<h3 id="deploying-with-kubernetes">Deploying with Kubernetes</h3>

<p>Well we have the image of shopfront in Java. Let&rsquo;s run this image called tuxisma/djshopfront:1.0 using k8s, change the &laquo;kubernetes&raquo; directory in the root of the project:</p>

<pre><code class="language-$">

We see in the yaml file the version of API(v1), kind of pod , the way of how need to write a yaml file is basically ```key: value``` where key is ***apiVersion*** and value is ***v1*** and so on.

Basically we have two types of structure in yaml file:

* Maps

* Lists 

### Maps

Usually you can find yamls in this way:

</code></pre>

<hr />

<p>apiVersion: v1
kind: Service
metadata:
  name: shopfront
  labels:
    app: shopfront</p>

<pre><code>
At the first line we have a separator could be optional but if you want to define multiple structures in the same file use it. Next we have a name(known as key) then a value, pay attention now the key metadata has other two more keys(name, labels) and labels key has another key named app and its value(shopfront). Labels is used to organize and to select subsets of objects, labels are ```key:value``` pairs as well.


Be careful with spaces, look onto yaml file notice that metadata key has two more keys as I mentioned both at the same level I will recommend you use two space left to right(see name and labels) 'cause both belong to metadata or if you want use one space at least, the goal is achieve the indentation as programming language tend to do. ***Please don't use tab*** 

### Lists

Yaml lists are sequence of objects:


</code></pre>

<p>args
  - sleep
  - &laquo;1000&raquo;
  - message
  - &laquo;Bring back Firefly!&raquo;</p>

<pre><code>

We can see any muber of items in a list which start with dash(-) idented from the parent(args).

And obviusly members of the list can be maps:

</code></pre>

<p>spec:
      containers:
      - name: nginxhttps
        image: tuxisma/djshopfront:1.0
        ports:
        - containerPort: 8010
        livenessProbe:
          httpGet:
            path: /health
            port: 8010
          initialDelaySeconds: 30
          timeoutSeconds: 1</p>

<pre><code>


### Let's put the shopfront-service.yaml file together


</code></pre>

<hr />

<p>apiVersion: v1
kind: Service
metadata:
  name: shopfront
  labels:
    app: shopfront
spec:
  type: NodePort
  selector:
    app: shopfront
  ports:
  - protocol: TCP
    port: 8010
    name: http</p>

<hr />

<p>apiVersion: v1
kind: ReplicationController
metadata:
  name: shopfront
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: shopfront
    spec:
      containers:
      - name: nginxhttps
        image: tuxisma/djshopfront:1.0
        ports:
        - containerPort: 8010
        livenessProbe:
          httpGet:
            path: /health
            port: 8010
          initialDelaySeconds: 30
          timeoutSeconds: 1</p>

<pre><code>
Here we are creating a service named &quot;shopfront&quot; that will route TCP traffic on port 8010 to pods using the label &quot;app:shopfront&quot;. The next structure creates a ```ReplicationController``` that says to k8s how many containers should run(one replica) as we have declared as part of the &quot;spec&quot;(specification) labelled as ```app: shopfront```. It's important specify that the port 8010 application traffic port in our Docker container is open, also we have a livenessProbe(healthcheck) which mean that k8s check if our containerized applications is running correctly and ready to acept traffic. 


Now, we need to start minikube in order to deploy this service(shopfront).

</code></pre>

<p>$ minikube start &ndash;cpus 2 &ndash;memory 4096
Starting local Kubernetes v1.7.5 cluster&hellip;
Starting VM&hellip;
Getting VM IP address&hellip;
Moving files into cluster&hellip;
Setting up certs&hellip;
Connecting to cluster&hellip;
Setting up kubeconfig&hellip;
Starting cluster components&hellip;
Kubectl is now configured to use the cluster.</p>

<pre><code>
Deploying:

</code></pre>

<p>$ kubectl apply -f shopfront-service.yaml
service &laquo;shopfront&raquo; created
replicationcontroller &laquo;shopfront&raquo; created</p>

<pre><code>

Let's check all the services within k8s:

</code></pre>

<p>$ kubectl get svc
NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)          AGE
kubernetes   10.0.0.1     <none>        443/TCP          18h
shopfront    10.0.0.216   <nodes>       8010:31208/TCP   12s</p>

<pre><code>
Now checking the pods:

</code></pre>

<p>$ kubectl get pods
NAME              READY     STATUS              RESTARTS   AGE
shopfront-0w1js   0/1       ContainerCreating   0          18s</p>

<pre><code>
As we can see the pod is just creating, what about now:

</code></pre>

<p>$ kubectl get pods
NAME              READY     STATUS    RESTARTS   AGE
shopfront-0w1js   <sup>1</sup>&frasl;<sub>1</sub>       Running   0          2m</p>

<pre><code>
Yeah!!!! We've just created our first service onto Kubernetes. 

As you can see the name of pod is ```shopfront-0w1js``` Afther the dash (-) we have a key of pod. 


### Testing

I will use curl in order to get data from shopfront application's healthcheck endpoint. 

</code></pre>

<p>$ curl $(minikube service shopfront &ndash;url)/health</p>

<pre><code>
And ...

</code></pre>

<p>{&laquo;status&raquo;:&laquo;UP&raquo;}</p>

<pre><code>
Everything is OK, the application is up and running.

### Building the remaining applicactions 

We have one container uo and running let's build the other two supporting microservice applications:

</code></pre>

<p>$ cd ..
$ cd productcatalogue/
$ docker run -it &ndash;rm -v $PWD:/usr/src/mymaven -w /usr/src/mymaven maven  mvn clean install
…
$ docker build -t tuxisma/djproductcatalogue:1.0 .
&hellip;
$ docker push tuxisma/djproductcatalogue:1.0
&hellip;
$ cd ..
$ cd stockmanager/
$ docker run -it &ndash;rm -v $PWD:/usr/src/mymaven -w /usr/src/mymaven maven  mvn clean install
…
&hellip;
$ docker build -t tuxisma/djstockmanager:1.0 .
&hellip;
$ docker push tuxisma/djstockmanager:1.0
…</p>

<pre><code>

We have built all of our microservices, associated Docker images, pushed the images to Docker Hub. We gonna deploy the &quot;productcatalogue&quot; and &quot;stockmanager&quot; services to Kubernetes.

###  Deploying the entire Java applications in Kubernetes

</code></pre>

<p>$ cd ..
$ cd kubernetes/
$ kubectl apply -f productcatalogue-service.yaml
service &laquo;productcatalogue&raquo; created
replicationcontroller &laquo;productcatalogue&raquo; created
$ kubectl apply -f stockmanager-service.yaml
service &laquo;stockmanager&raquo; created
replicationcontroller &laquo;stockmanager&raquo; created
$ kubectl get svc
NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
kubernetes         ClusterIP   10.0.0.1       <none>        443/TCP          19h
productcatalogue   NodePort    10.0.0.37      <none>        8020:30160/TCP   42s
shopfront          NodePort    10.0.0.216     <none>        8010:30019/TCP   13m
stockmanager       NodePort    10.0.0.149     <none>        8030:31089/TCP   16s</p>

<p>$ kubectl get pods
NAME                     READY     STATUS    RESTARTS   AGE
productcatalogue-79qn4   <sup>1</sup>&frasl;<sub>1</sub>       Running   0          55s
shopfront-0w1js          <sup>1</sup>&frasl;<sub>1</sub>       Running   0          13m
stockmanager-lmgj9       <sup>1</sup>&frasl;<sub>1</sub>       Running   0          29s</p>

<pre><code>

### How looks the complete application

Let's acces to application via the shopfront servie GUI. Our application will open the service in our default browser on my way is Firefox, use the following command in minikube:

</code></pre>

<p>$ minikube service shopfront
```</p>

<p>See the magic!</p>

<p><img src="https://farm5.staticflickr.com/4670/24840666857_8bd11c3cb1_b.jpg" alt="shopfront-kubernetes" title="Shopfront" /></p>

<p>We&rsquo;ve deployed our microservices using Kubernetes &lt;3</p>

<p>Source:</p>

<ul>
<li><p><a href="https://github.com/danielbryantuk/oreilly-docker-java-shopping" target="_blank">https://github.com/danielbryantuk/oreilly-docker-java-shopping</a></p></li>

<li><p><a href="https://kubernetes.io/docs/home/" target="_blank">https://kubernetes.io/docs/home/</a></p></li>

<li><p><a href="https://www.oreilly.com/ideas/how-to-manage-docker-containers-in-kubernetes-with-java?utm_content=buffera6cd5&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer" target="_blank">https://www.oreilly.com/ideas/how-to-manage-docker-containers-in-kubernetes-with-java?utm_content=buffera6cd5&amp;utm_medium=social&amp;utm_source=twitter.com&amp;utm_campaign=buffer</a></p></li>
</ul>

      </article>

      <p class="post-meta">Tags:&nbsp;
        
            
            <a href="https://tuxisma.github.io/tags/cloudComputing">cloudComputing</a>
        
      </p>

      

    </div>
  </div>
</div>
    <footer class="footer">
      <div class="p2 wrap">
        <div class="measure mt1 center">
      <nav class="social-icons icons">
<a class="fa fa-rss rss" href="../../index.xml"></a>

<a class="fa fa-twitter twitter" href="https://twitter.com/tuxisma" target="_blank"></a>

</nav>

          <small>
            Copyright &#169; 2019<br>
	   
          </small>
        </div>
      </div>
    </footer>

    
    <script src="../../js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    
    


</body>
</html>

